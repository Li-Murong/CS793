An Improved Relaxation for Oracle-Efficient
Adversarial Contextual Bandits
Kiarash Banihashem
University of Maryland, College Park
kiarash@umd.edu

MohammadTaghi Hajiaghayi
University of Maryland, College Park
hajiagha@umd.edu

Suho Shin
University of Maryland, College Park
suhoshin@umd.edu

Max Springer
University of Maryland, College Park
mss423@umd.edu

Abstract
We present an oracle-efficient relaxation for the adversarial contextual bandits
problem, where the contexts are sequentially drawn i.i.d from a known distribution
and the cost sequence is chosen by an online adversary. Our algorithm has a regret
2
1
bound of O(T 3 (K log(|Î |)) 3 ) and makes at most O(K) calls per round to an
offline optimization oracle, where K denotes the number of actions, T denotes
the number of rounds and Î  denotes the set of policies. This is the first result to
2
1
improve the prior best bound of O((T K) 3 (log(|Î |)) 3 ) as obtained by Syrgkanis
et al. at NeurIPS 2016, and the first to match the original bound of Langford and
Zhang at NeurIPS 2007 which was obtained for the stochastic case.

1

Introduction

One of the most important problems in the study of online learning algorithms is the contextual
bandits problem. As a framework for studying decision making in the presence of side information,
the problem generalizes the classical multi-armed bandits problem and has numerous practical
applications spanning across clinical research, personalized medical care and online advertising, with
substantial emphasis placed on modern recommender systems.
In the classical multi-armed bandits problem, a decision maker is presented with K actions (or arms)
which it needs to choose from over a sequence of T rounds. In each round, the decision maker makes
its (possibly random) choice and observes the cost of its chosen action. Depending on the setting,
this cost is generally assumed to be either stochastic or adversarial. In the stochastic setting, the cost
of each action is sampled i.i.d. from a fixed, but a priori unknown, distribution. In the more general
adversarial setting, no such assumption is made and the costs in each round can be controlled by an
online adversary. The goal of the learner is to minimize its regret, defined as the absolute difference
between its total cost and the total cost of the best fixed action in hindsight.
The contextual bandits problem generalizes this by assuming that in each round, the learner first
sees some side information, referred to as a context, x âˆˆ X and chooses its action based on this
information. As in prior work (Rakhlin and Sridharan, 2016; Syrgkanis et al., 2016b), we assume that
the x are sampled i.i.d. from a fixed distribution D, and that the learner can generate samples from D
as needed. In addition, the learner has access to a set of policies, Î , where a policy is defined as a
mapping from contexts to actions. As before, the goal of the learner is to minimize its regret, which
we here define as the absolute difference between its total cost and the total cost of the best policy of
Î  in hindsight.
37th Conference on Neural Information Processing Systems (NeurIPS 2023).

It is well-known that by viewing each policy as an expert, the problem can be reduced to the bandits
with experts problem where, even in thep
adversarial setting, the E XP4 (Auer et al., 1995) algorithm
achieves the optimal regret bound of O( T K log(|Î |)). Computationally however, the reduction is
inefficient as the algorithmâ€™s running time would be linear in |Î |. Since the size of the policy set, Î ,
can be very large (potentially exponential), the utility of this algorithm is restricted in practice.
Given the computational challenge, there has been a surge of interest in oracle-efficient algorithms.
In this setting, the learner is given access to an Empirical Risk Minimization (ERM) optimization
oracle which, for any sequence of pairs of contexts and loss vectors, returns the best fixed policy in Î .
This effectively reduces the online problem to an offline learning problem, where many algorithms
(e.g., SVM) are known to work well both in theory and practice. This approach was initiated by the
seminal work of Langford and Zhang (2007), who obtained a regret rate of O(T 2/3 (K log |Î |)1/3 )
for stochastic rewards, using
p an -greedy algorithm. This was later improved to the informationtheoretically optimal O( T K log |Î |) (Dudik et al., 2011). Subsequent works have focused on
improving the running time of these algorithms (Beygelzimer et al., 2011; Agarwal et al., 2014;
Simchi-Levi and Xu, 2022), and extending them to a variety of problem settings such as auction
design (DudÃ­k et al., 2020), minimizing dynamic regret (Luo et al., 2018; Chen et al., 2019), bandits with knapsacks (Agrawal et al., 2016), semi-bandits (Krishnamurthy et al., 2016), corralling
bandits (Agarwal et al., 2017), smoothed analysis (Haghtalab et al., 2022; Block et al., 2022), and
reinforcement learning (Foster et al., 2021).
Despite the extensive body of work, progress for adversarial rewards has been slow. Intuitively,
approaches for the stochastic setting do not generalize to adversarial rewards because they try to
â€œlearn the environmentâ€ and in the adversarial setting, there is no environment to be learnt. This
issue can be seen in the original multi-armed bandits problem as well. While the regret bounds
for the adversarial setting and the stochastic setting are the same, the standard approaches are very
different. 1 In the stochastic setting, the most standard approach is the UCB1 algorithm (Auer et al.,
2002), which is intuitive and has a relatively simple analysis. In the adversarial setting however, the
standard approach is considerably more complex: the problem is first solved in the â€œfull feedbackâ€
setting, where the learner observes all of the rewards in each iteration, using the Hedge algorithm.
This is then used as a black box to obtain an algorithm for the partial (or bandit) feedback setting
by constructing unbiased estimates for the rewards vector. The analysis is also much more involved
compared to UCB1; a standard analysis of theâˆš
black box reduction leads to the suboptimal bound of
T 3/4 K 1/2 , and further obtaining the optimal T K bound requires a more refined second moment
analysis (see Chapter 6 of Slivkins (2019) for a more detailed overview).
As a result, oracle-efficient algorithms for the adversarial setting were first proposed by the independent works of Rakhlin and Sridharan (2016) and Syrgkanis et al. (2016a) in ICML 2016, who
obtained a regret bound of O(T 3/4 K 1/2 log(|Î |)1/4 ) and left obtaining improvements as an open
problem. This was subsequently improved to O((T K)2/3 log(|Î |)1/3 ) by Syrgkanis et al. (2016b) at
NeurIPS 2016.
1.1

Our contribution and techniques

In this work, we design an oracle-efficient algorithm with a regret bound of O(T 2/3 (K log |Î |)1/3 ).
Our result is the first improvement after that of Syrgkanis et al. (2016b), and maintains the best
regret upper bound to the extent of our knowledge. This is also the first result to match the bound
of Langford and Zhang (2007), the original baseline algorithm for the stochastic version of the
problem. We state the informal version of our main result (Theorem 7) in the following.
Theorem 1 (Informal). For large enough T ,2 there exists an algorithm (Algorithm 1) that achieves
expected regret on the order of O(T 2/3 (K log |Î |)1/3 ) for the adversarial contextual bandits problem
using at most O(K) calls per round to an ERM oracle.
In order to compare this result with prior work, it is useful to consider the regime of K = T Î± for
a constant Î± > 0. In this regime, our work leads to a sublinear regret bound for any Î± < 1, while
1
We note that any approach for the adversarial setting works for the stochastic setting as well. However, both
in theory and practice, specialised approaches are more commonly used.
2
When T is small, our improvement compared to prior work is more significant; we focus on the large T
setting to obtain a fair comparison.

2

prior work (Rakhlin and Sridharan, 2016; Syrgkanis et al., 2016b) can only obtain sublinear regret
for Î± < 1/2.
Our improved dependence on K is important practically since, for many real-world implementations
such as recommender systems, the number of possible actions is very large. Additionally, many
bandits algorithms consider â€œfake" actions as part of a reduction. For example, a large number of
actions may be considered as part of a discretization scheme for simulating a continuous action space
(Slivkins, 2009). In such cases, the improved dependence on K could potentially imply an overall
improvement with respect to T , as the parameters in the algorithm are often chosen in such a way
that optimizes their trade-off.
From a technical standpoint, our result builds on the existing works based on the relax-and-randomize
framework of Rakhlin et al. (2012). Rakhlin and Sridharan (2015) used this framework, together with
the â€œrandom playoutâ€ method, to study online prediction problems with evolving constraints under
the assumption of a full feedback model. Rakhlin and Sridharan (2016) extended these techniques
to the partial (bandit) feedback model, and developed the BISTRO algorithm which achieves a
O(T 3/4 K 1/2 log(|Î |)1/4 ) regret bound for the adversarial contextual bandits problem. Subsequently,
Syrgkanis et al. (2016b) used a novel distribution of hallucinated rewards as well as a sharper second
moment analysis to obtain a regret bound of O((T K)2/3 log(|Î |)1/3 ). We further improve the regret
rate to O(T 2/3 (K log(|Î |))1/3 ) by reducing the support of the hallucinated rewards vector to a single
random entry. We note the previous approaches of Rakhlin and Sridharan (2016); Syrgkanis et al.
(2016b), as well as the closely related work of Rakhlin and Sridharan (2015), set all of the entries of
the hallucinated cost to i.i.d Rademacher random variables.
We show that our novel relaxation preserves the main properties required for obtaining a regret bound,
specifically, it is admissible. We then prove that the Rademacher averages term that arises from our
new relaxation improves by a factor of K, which consequently leads to a better regret bound. We
further refer to Section 3 for a more detailed description of our algorithm, and to Section 4 for the
careful analysis.

1.2

Related work

Contextual bandits. There are three prominent problem setups broadly studied in the contextual
bandits literature: Lipschitz contextual bandits, linear contextual bandits, and contextual bandits
with policy class. Lipschitz contextual bandits (Lu et al., 2009; Cutkosky and Boahen, 2017) and
linear contextual bandits (Chu et al., 2011) assume a structured payoff based on a Lipschitz or
linear realizability assumption, respectively. The strong structural assumptions made by these works
however make them impractical for many settings.
To circumvent this problem, many works consider contextual bandits with policy classes where the
problem is made tractable by making assumptions on the benchmark of regret. In these works, the
learner is given access to a policy class Î  and competes against the best policy in Î . This approach
also draws connections to offline machine learning models that in recent years have had a huge
impact on many applications. In order for an algorithm to be useful in practice however, it needs to
be computationally tractable, thus motivating the main focus of this work.
Online learning with adversarial rewards. Closely related to our work is the online learning with
experts problem where, in each round, the learner observes a set of N experts making recommendations for which action to take, and decides which action to choose based on these recommendations.
The goal of the learner is to minimize its regret with respect to the best expert in hindsight. In the full
feedback setting, where the learner observes the cost of all actions, the well-known Hedge (CesaBianchi et al., 1997) algorithm basedâˆšon a randomized weighted majority selection rule achieves
the best possible regret bound of O( T ln N ). Correspondingly, in the partial feedback setting,
E XP4 (Auer et al., 1995) exploits Hedge by constructing unbiased â€œhallucinatedâ€ costs
âˆš based on the
inverse propensity score technique, and achieves the optimal regret bound of O( KT ln N ). By
considering an expert for each policy, the contextual bandits problem can be reduced to this problem.
This reduction suffers from computational intractability however due to the linear dependence on |Î |
in the running time. Since the number of policies can be very large in practice, this poses a major
bottleneck in many cases. We alleviate this intractability issue through a computationally feasible
oracle-based algorithm with improved regret bound.
3

Oracle efficient online learning. Stemming from the seminal work of Kalai and Vempala (2005),
there has been a long line of work investigating the computational barriers and benefits of online
learning in a variety of paradigms. Broadly speaking, the bulk of online algorithms are designed
on the basis of two popular frameworks in this literature: follow-the-perturbed-leader (Kalai and
Vempala, 2005; Suggala and Netrapalli, 2020; DudÃ­k et al., 2020; Haghtalab et al., 2022) and relaxand-randomize (Rakhlin et al., 2012). Both frameworks aim to inject random noise into the input
set before calling an oracle to construct a more robust sequence of actions to be played against
an adversary, but differ in how they introduce such noise to the system. Our algorithm builds on
the relax-and-randomize technique and improves upon the previous best result of Syrgkanis et al.
(2016b).
Despite their computational advantages, it is known that oracle efficient algorithms have fundamental
limits and, in some settings, they may not achieve optimal regret rates (Hazan and Koren, 2016).
Whether this is the case for the adversarial contextual bandits problem remains an open problem.

2

Preliminaries

In this section, we explain the notation and problem setup, and review the notion of relaxation based
algorithms in accordance with prior work (Rakhlin and Sridharan, 2016; Syrgkanis et al., 2016b).
2.1

Notation and problem setup

Given an integer K, we use [K] to denote the set { 1, . . . , K } and a1:K to denote { a1 , . . . , ak }. We
similarly use (a, b, c)1:K to denote the set of tuples { (a1 , b1 , c1 ), . . . , (aK , bK , cK ) }. The vector of
zeros is denoted as 0, and similarly, the vector of ones is denoted 1.
We consider the contextual bandits problem with [T ] rounds. In each round t âˆˆ [T ], a context xt is
shown to the learner, who chooses an action yÌ‚t âˆˆ [K], and incurs a loss of ct (yÌ‚t ), where ct âˆˆ [0, 1]k
denotes the cost vector. The choice of the action yÌ‚t can be randomized and we assume that the learner
samples yÌ‚t from some distribution qt . The cost vector is chosen by an adversary who knows the cost
vector xt and the distribution qt but, crucially, does not know the value of yÌ‚t .
As in prior work (Rakhlin and Sridharan, 2016; Syrgkanis et al., 2016b), we operate in the hybrid
i.i.d-adversarial model where xt is sampled from some fixed distribution D, and the learner has
sampling access to the distribution D. We additionally assume that the feedback to the learner is
partial, i.e., the learner only observes ct (yÌ‚t ) and not the full cost vector ct .
The learnerâ€™s goal is to minimize its total cost compared to a set of policies Î , where a policy is
defined as a mapping from contexts to actions. Formally, the learner aims to minimize its regret,
which we define as
R EG :=

T
X

hqt , ct i âˆ’ inf

Ï€âˆˆÎ 

t=1

T
X

ct (Ï€(xt )),

t=1

where hqt , ct i denotes the dot product of qt and ct , and inf denotes the infimum.
We assume that the learner has access to a value-of-ERM optimization oracle that takes as input a
sequence of contexts and cost vectors (x, c)1:t , and outputs the minimum cost obtainable by a policy
Pt
in Î , i.e., inf Ï€âˆˆÎ  Ï„ =1 cÏ„ (Ï€(xÏ„ )).
2.2

Relaxation Based Algorithms

In each round t âˆˆ [T ] after selecting an action and observing the adversarial cost, the learner obtains
an information tuple, which we denote by It (xt , qt , yÌ‚t , ct (yÌ‚t ), St ). Here, yÌ‚ âˆ¼ qt is the action chosen
from the learnerâ€™s distribution, and St is the internal randomness of our algorithm, which can also be
used in the subsequent rounds.
Given the above definition, the notions of admissible relaxation and admissible strategy are defined
as follows.
Definition 2. A partial information relaxation R EL(Â·) is a mapping from the information sequence
(I1 , ..., It ) to a real value for any t âˆˆ [T ]. Moreover, a partial-information relaxation is deemed
4

admissible if for any such t, and for all I1 , ..., Itâˆ’1 :


Ext âˆ¼D inf qt supct EyÌ‚t âˆ¼qt ,St [ct (yÌ‚t ) + R EL(I1:t )] â‰¤ R EL(I1:tâˆ’1 ),

(1)

and for all x1:T , c1:T and q1:T :
EyÌ‚1:T âˆ¼qt ,S1:T [R EL(I1:T )] â‰¥ âˆ’ inf
Ï€

T
X

ct (Ï€(xt )).

(2)

t=1

A randomized strategy q1:T is admissible if it certifies the admissibility conditions (1) and (2).
Intuitively, relaxation functions allow us to decompose the regret across time steps, and bound each
step separately using Equation (1). The following lemma formalizes this idea.
Lemma 3 (Rakhlin and Sridharan (2016)). Let R EL be an admissible relaxation and q1:T be a
corresponding admissible strategy. Then, for any c1:T , we have the bound
E [R EG] â‰¤ R EL(âˆ…).

3

Contextual Bandits Algorithm

We here define an admissible strategy in correspondence with the relaxation notion from the prior
section, and use it to outline our contextual bandits algorithm. As mentioned in Section 1.1, our
algorithm is based on the BISTRO+ algorithm of Syrgkanis et al. (2016b), and our improvement
is obtained by defining a new relaxation function, which we discuss below. We discuss how this
improves the regret bound in Section 4.
Unbiased cost vectors. In order to handle the partial feedback nature of the problem, we use the
standard technique of forming an unbiased cost vector from the observed entry, together with the
discretization scheme of Syrgkanis et al. (2016b). Let Î³ < 1 be a parameter to be specified later.
Using the information It collected on round t, we set our estimator to be the random vector whose
elements are defined by a Bernoulli random variable
(
ct (yÌ‚t )
KÎ³ âˆ’1 Â· 1 [i = yÌ‚t ] with probability Î³ Â· Kq
t (yÌ‚t ) .
cÌ‚t (i) =
(3)
0
otherwise
We note that this is only defined for mini qt (i) â‰¥ Î³/K, thus imposing a constraint that must be
ensured by our algorithm. It is easy to verify that this vector is indeed an unbiased estimator:
EyÌ‚t âˆ¼qt [cÌ‚t (i)] = qt (i) Â· Î³

ct (i)
Â· KÎ³ âˆ’1 = ct (i).
Kqt (i)

Relaxation function. We first construct a one-hot Rademacher random vector by randomly sampling
an action i âˆˆ [K] and setting Îµt (j) = 0 for i 6= j and Îµt (i) to a Rademacher random variable in
{âˆ’1, 1}. We additionally define Zt âˆˆ {0, KÎ³ âˆ’1 } that takes value KÎ³ âˆ’1 with probability Î³ and 0
otherwise. Using the notation Ït for the random variable tuple (x, Îµ, Z)t+1:T , we define our relaxation
R EL as
R EL(I1:t ) = EÏt [R((x, cÌ‚t )1:t , Ït )] ,
(4)
where R((x, cÌ‚t )1:t , Ït ) is defined to be
!
t
T
X
X
Î³(T âˆ’ t) âˆ’ inf
cÌ‚(Ï€(xÏ„ )) +
2ZÏ„ ÎµÏ„ (Ï€(xÏ„ )) .
Ï€

Ï„ =1

Ï„ =t+1

We note the contrast between the above definition and the relaxation frameworks used in prior
work (Rakhlin and Sridharan, 2015, 2016; Syrgkanis et al., 2016b): These works all set every entry
in Îµt to a Rademacher random variables, while we set only a single (randomly chosen) entry to a
Rademacher random variable and set the rest of the entries to zero.
The changes in the relaxtion function are motivated by the algorithm analysis (see Section 4).
Specifically, in order to ensure admissibility, the symmetrization step of the Relax and randomize
framework applies only to a single (random) action. Applying noise to all the entries, as is done in
5

prior work, leads to valid upper bound but is not tight. As we show in Lemma 9, applying noise to a
single entry is sufficient, as long as this entry is chosen uniformly at random. The reduced noise leads
to an improved Rademacher averages term (see Theorem 6), which in turn leads to a better regret
bound.
Randomized strategy. As in prior work (Rakhlin and Sridharan, 2015, 2016; Syrgkanis et al., 2016b),
we use the â€œrandom playoutâ€ technique to define our strategy. We use hallucinated future cost vectors,
together with unbiased estimates of the past cost, to choose a strategy that minimizes the total cost
across T rounds.
Define D := {KÎ³ âˆ’1 Â· ei : i âˆˆ [K]} âˆª {0}, where ei is the i-th standard basis vector in K dimensions.
We further define âˆ†D , the set of distributions over D, and âˆ†0D âŠ† âˆ†D to be the set
Î³
{p âˆˆ âˆ†D : max p(i) â‰¤ }.
(5)
K
iâˆˆ[K]
Recall that Ït denotes the random variable tuple (x, Îµ, Z)t+1:T . We sample Ït and define qtâˆ— (Ït ) as:
qtâˆ— (Ït ) := min sup EcÌ‚t âˆ¼pt [hq, cÌ‚t i + R((x, cÌ‚)1:t , Ït )] .
qâˆˆâˆ†K pt âˆˆâˆ†0

(6)

D

We than sample the action yÌ‚t from the distribution qt (Ït ) defined as
Î³
qt (Ït ) := (1 âˆ’ Î³)qtâˆ— (Ït ) +
Â· 1.
K

(7)

In order to calculate qt (Ït ), we use a water-filling argument similar to Rakhlin and Sridharan (2016)
and Syrgkanis et al. (2016b). Formally, we will use the following lemma, the proof of which is in
Appendix B.
Lemma 4. There exists a water-filling algorithm that computes the value qtâˆ— (Ït ) for any given Ït in
time O(K) with only K + 1 accesses to a value-of-ERM oracle in every round.
A full pseudocode of our approach is provided in Algorithm 1.
Algorithm 1: Contextual Bandits Algorithm
for t = 1, 2, . . . , T do
Observe context xt
Draw random variable tuple Ït = (x, Îµ, Z)t+1:T
Compute qt (Ït ) via Equation 7
Draw action yÌ‚t âˆ¼ qt (Ït ) and observe ct (yÌ‚t )
Estimate cost vector cÌ‚t via Equation 3
end

4

Analysis

In this section, we provide the formal statement of our theoretical guarantees and discuss their proofs.
Due to space constraints, some of the proofs are deferred to the supplementary material.
As mentioned in the introduction, our main novelty is the use of a new relaxation function, which
we discussed in Section 3, that uses less variance in the hallucinated cost vectors. Our initial result
verifies that the our novel relaxation is indeed admissible and, as a result, we can leverage the prior
work demonstrating the expected regret of these algorithms.
Theorem 5. The relaxation function defined in (4), and the corresponding strategy (7) are admissible
(Definition 2).
Theorem 5 contrasts with existing admissible relaxations in that it only uses a single Rademacher
variable for each time step, while prior work â€“ Lemma 2 in Rakhlin and Sridharan (2015), Theorem 2
in Rakhlin and Sridharan (2016) and Theorem 3 in Syrgkanis et al. (2016b) â€“ all use k independent
Rademacher variables. To our knowledge, this is the first work in which the number of Rademacher
variables used in the relaxation does not grow with the number of arms. As we discuss below, this
6

allows us to reduce the variance of the hallucinated costs, leading to a better regret bound. The proof
of Theorem 5 is provided in Section 4.1, and is based on a novel symmetrization step (Lemma 9),
which may be of independent interest.
As highlighted in Section 2.2, admissible relaxations are a powerful framework for upper bounding
the expected regret in online learning through Lemma 3 and the value of R EL(âˆ…). Formally, Lemma
3 implies
"
!#
T
X
E [R EG] â‰¤ R EL(âˆ…) = Î³T + EÏ0 sup
2ZÏ„ ÎµÏ„ (Ï€(xÏ„ ))
.
(8)
Ï€âˆˆÎ 

Ï„ =1

In order to bound the regret of our algorithm, it suffices to bound the Rademacher averages term
above, which we formally do in the following Theorem.
Theorem 6. For any Î³ > K
T log(|Î |)/2, the following holds:
s
"
#
T
X
KT log |Î |
E(Z,Îµ)1:T sup
.
Zt Îµt (Ï€(xt )) â‰¤ 2
Î³
Ï€âˆˆÎ  i=1
The above theorem can be thought of as an improved version of Lemma 2 from Syrgkanis et al.
(2016b), where we improve by a factor of K. Our improvement comes from the use of the new
Rademacher vectors that only contain a single non-zero coordinate, together with a more refined
analysis. We refer to Section 4.2 for a formal proof of the result.
Combining Lemma 4, Equation (8), and Theorem 6, we obtain the main result of our paper which we
state here.
Theorem 7. The contextual bandits algorithm implemented in Algorithm 1 has expected regret upper
bounded by
s
T K log(|Î |)
+ Î³T,
4
Î³
|Î |
for any K log
< Î³ â‰¤ 1, which implies the regret order of O((K log |Î |)1/3 T 2/3 ) when T >
2T
4K log(|Î |). Furthermore, the Algorithm makes at most K + 1 calls to a value-of-ERM oracle in
each round.

We refer to Appendix A for the proof of this result.
4.1

Proof of Theorem 5

In order to prove Theorem 5, we need to verify the final step condition (2), and show that the qt
defined in Equation (7) certifies the condition (1), i.e.,


Ext sup EyÌ‚t ,St [ct (yÌ‚t ) + R EL(I1:t )] â‰¤ R EL(I1:tâˆ’1 ),
(9)
ct

where yÌ‚t is sampled from qt and I1:t denotes (I1:tâˆ’1 , It (xt , qt , yÌ‚t , ct , St )). Verifying condition (2) is
standard and we do this in Appendix D. It remains to prove Equation (9). Since most admissibility
proofs in the literature (Rakhlin et al., 2012; Rakhlin and Sridharan, 2015, 2016; Syrgkanis et al.,
2016b) follow the framework of the original derivation of Rakhlin et al. (2012), in order to emphasize
our novelty, we divide the proof into two parts. The first part (Lemma 8) is based on existing
techniques (in particular, the proof of Theorem 3 in Syrgkanis et al. (2016b)) and its proof is provided
in Appendic C. The second part (Lemma 9) uses new techniques and we present its proof here.
Lemma 8. For any t âˆˆ [T ], define AÏ€,t and Ct as
AÏ€,t := âˆ’

tâˆ’1
X
Ï„ =1

cÌ‚Ï„ (Ï€(xÏ„ )) âˆ’

T
X

2ZÏ„ ÎµÏ„ (Ï€(xÏ„ )),

Ct := Î³(T âˆ’ t + 1).

Ï„ =t+1

Letting Î´ denote a Rademacher random variable independent of Ït and cÌ‚t , the following holds for
any value of xt :
"

#
sup EyÌ‚t ,St [ct (yÌ‚t ) + R EL(I1:t )] â‰¤ EÏt sup EcÌ‚t âˆ¼pt ,Î´ sup (2Î´cÌ‚t (Ï€(xt )) + AÏ€,t ) + Ct .
ct

pt âˆˆâˆ†0D

7

Ï€âˆˆÎ 

Lemma 9. Defining AÏ€,t as in Lemma 8, the following bound holds for any t âˆˆ [T ]:




sup EcÌ‚t âˆ¼pt ,Î´ sup (2Î´cÌ‚t (Ï€(xt )) + AÏ€,t ) â‰¤ EÎµt ,Zt sup (2Zt Â· Îµt (Ï€(xt )) + AÏ€,t ) .

pt âˆˆâˆ†0D

Ï€âˆˆÎ 

(10)

Ï€âˆˆÎ 

Combining the above lemmas we obtain Equation (9) by definition of R EL:
"

#


Ext sup EyÌ‚t ,St [ct (yÌ‚t ) + R EL(I1:t )] â‰¤ Ext ,Ït sup EcÌ‚t ,Î´ sup (2Î´cÌ‚t (Ï€(xt )) + AÏ€,t ) + Ct
pt âˆˆâˆ†0D

ct

Ï€âˆˆÎ 




â‰¤ Ext ,Îµt ,Zt ,Ït sup (2Zt Â· Îµt (Ï€(xt )) + AÏ€,t ) + Ct
Ï€âˆˆÎ 


â‰¤ EÏtâˆ’1 sup (2Zt Â· Îµt (Ï€(xt )) + AÏ€,t ) + Ct
Ï€âˆˆÎ 

â‰¤ R EL(I1:tâˆ’1 ).

Proof of Lemma 9. For any distribution pt âˆˆ âˆ†0D , the distribution of the each coordinate of cÌ‚t has
âˆ’1
support
on {0, Î³ âˆ’1 K}

 and is equal to Î³ K with probability at most Î³/K. Using pt (i) to denote
âˆ’1
P cÌ‚t (i) = Î³ K Â· ei we can rewrite the LHS (left hand side) of Equation (10) as

sup EcÌ‚t âˆ¼pt ,Î´

pt âˆˆâˆ†0D


sup (2Î´cÌ‚t (Ï€(xt )) + AÏ€,t )

Ï€âˆˆÎ 

!

2KÎ´
1 [Ï€(xt ) = i]
= sup (1 âˆ’
pt (i)) sup AÏ€,t +
pt (i)EÎ´ sup AÏ€,t +
Î³
Ï€
Ï€
pt âˆˆâˆ†0D
i
i
!

X
X
2KÎ´
=
sup
(1 âˆ’
pt (i)) sup AÏ€,t +
pt (i)EÎ´ sup AÏ€,t +
1 [Ï€(xt ) = i] ,
Î³
Ï€
Ï€
0â‰¤pt (i)â‰¤Î³/K
i
i
X

X

where the first equality follows from expanding the expectation with respect to cÌ‚t , and the second
equality follows from the definition of âˆ†0D . We argue that this value is maximized when each pt (i)
takes on its maximum value, i.e., Î³/K. It suffices to observe that





2KÎ´
2KÎ´
EÎ´ sup AÏ€,t +
1 [Ï€(xt ) = i] â‰¥ sup AÏ€,t + EÎ´
1 [Ï€(xt ) = i]
= sup AÏ€,t ,
Î³
Î³
Ï€
Ï€
Ï€
where the inequality follows from the fact that supremum of expectation is less than expectation
of supremum, and the equality uses the fact that E [Î´] = 0. Therefore, we maximize the LHS of
Î³
Equation (10) via selecting pt that satisfies pt (i) = K
for i â‰¥ 1. It follows that


sup EcÌ‚t âˆ¼pt ,Î´ sup (2Î´cÌ‚t (Ï€(xt )) + AÏ€,t )

pt âˆˆâˆ†0D

Ï€âˆˆÎ 


!
2KÎ´
â‰¤ (1 âˆ’ Î³) sup AÏ€,t +
EÎ´ sup AÏ€,t +
1 [Ï€(xt ) = i]
K
Î³
Ï€
Ï€
i


= EÎµt ,Zt sup (2Zt Â· Îµt (Ï€(xt )) + AÏ€,t ) ,
X Î³

Ï€âˆˆÎ 

finishing the proof.
8

4.2

Proof of Theorem 6

We start with the following standard inequalities for handling the supremum using the moment
generating function.
"
#

 

T
X
PT
1
E(Z,Îµ)1:T sup
Zt Îµt (Ï€(xt )) = EZ1:T
Â· EÎµ1:T log sup eÎ» t=1 Zt Îµt (Ï€(xt ))
Î»
Ï€âˆˆÎ  i=1
Ï€âˆˆÎ 
"
!##
"
X PT
1
Î» t=1 Zt Îµt (Ï€(xt ))
e
Â· EÎµ1:T log
â‰¤ EZ1:T
Î»
Ï€âˆˆÎ 
"
"
#!#
X PT
(i)
1
â‰¤ EZ1:T
Â· log EÎµ1:T
eÎ» t=1 Zt Îµt (Ï€(xt ))
Î»
Ï€âˆˆÎ 
!#
"
T
i
h
X
Y
1
(ii)
Î»Zt Îµt (Ï€(xt ))
Â· log
EÎµt e
.
= EZ1:T
Î»
t=1
Ï€âˆˆÎ 

Inequality (i) holds due to the concavity of log andâˆš(ii) follows from the independence of Îµt . We will
additionally assume that Î» is upper bounded by Î³ 2/K in the remaining analysis.
By our construction of the random variable Îµt , for any fixed Ï€, Îµt (Ï€(xt )) takes the value 0 with
1
1
probability 1 âˆ’ K
and the values âˆ’1 and 1 each with probability 2K
. We therefore have that


h
i
1
1
1
+
Â· eÎ»Zt +
Â· eâˆ’Î»Zt
EÎµt eÎ»Zt Îµt (Ï€(xt )) = 1 âˆ’
K
2K
2K
2 2
1
1
â‰¤1âˆ’
+
Â· eÎ» Zt /2
K
K
1

â‰¤ e K (e

Î»2 Zt2 /2

âˆ’1)

.

2

The first inequality above uses ex + eâˆ’x â‰¤ 2ex /2 while the second inequality uses ex â‰¥ 1 + x for
x âˆˆ R. This further yields
!#
!#
"
"
T
T
h
i
Î»2 Zt2 /2
Y
XY
e
âˆ’1
1
1
Î»Zt Îµt (Ï€(xt ))
K
e
Â· log
EÎµt e
Â· log |Î | Â·
EZ1:T
â‰¤ EZ1:T
Î»
Î»
t=1
Ï€âˆˆÎ  t=1
#
"
2 2
T
X
eÎ» Zt /2 âˆ’ 1
1
log(|Î |) +
= EZ1:T
Î»
Î»K
t=1
=

T
h 2 2
i
log(|Î |)
1 X
+
EZ1:T eÎ» Zt /2 âˆ’ 1 .
Î»
Î»K t=1

Recall that Zt takes the values 0 and K
Î³ with probabilities 1 âˆ’ Î³ and Î³ respectively. It follows that
 2 2

h 2 2
i
Î» K
Î»2 K 2
Î» Zt /2
2
2Î³
EZ1:T e
âˆ’1 =Î³ e
âˆ’1 â‰¤Î³ 2 ,
Î³
where âˆš
the inequality follows from the fact that ex âˆ’ 1 â‰¤ 2x for x âˆˆ (0, 1) and the assumption
Î» â‰¤ Î³ 2/K. Therefore,
"
!#
T
h
i
XY
1
log(|Î |) T KÎ»
Î»Zt Îµt (Ï€(xt ))
EZ1:T
Â· log
EÎµt e
â‰¤
+
.
Î»
Î»
Î³
t=1
Ï€âˆˆÎ 

By taking derivative with respect to Î» we obtain
âˆ’ log(|Î |)
+ T K/Î³ = 0,
Î»2
9

q
and compute that the equation above is minimized at Î» = Î³ log(|Î |)
. We note that Î» satisfies the
TK
âˆš
log(|Î |)
Î³
assumption Î» â‰¤ Î³ 2/K because this is equivalent to 2T < K , which holds by the assumption
of the lemma. Plugging this again yields
s
r
p
T K Î³ log(|Î |)
TK
log(|Î |)
+
= 2 T K log(|Î |)/Î³,
Î³ log(|Î |)
Î³
TK
which is the desired bound.

5

Conclusion

In this paper, we presented a novel efficient relaxation for the adversarial contextual bandits problem
and proved that its regret is upper bounded by O(T 2/3 (K log |Î |)1/3 ). This provides a marked
improvement with respect to the parameter K as compared to the prior best result and matches
the original baseline of Langford and Zhang (2007) for the stochastic version
p of the problem. As
mentioned earlier, non-efficient algorithms can obtain a regret bound of O( T K log(|Î |)), which
is information theoretically optimal. While oracle-efficient algorithms can obtain the optimal regret
bound in the stochastic setting (Dudik et al., 2011), they do not always achieve optimal regret
rates (Hazan and Koren, 2016). Whether or not optimal regret can be obtained in our setting using
efficient algorithms remains an open problem and improving both the upper and lower bounds are
interesting directions for future work. Additionally, while our work operates in the same setting as
prior work (Rakhlin and Sridharan, 2016; Syrgkanis et al., 2016b), it would be interesting to relax
some of the assumptions in the setting, most notably the sampling access to the context distribution.

6

Acknowledgements

This work is partially supported by DARPA QuICC NSF AF:Small #2218678, and NSF AF:Small
#2114269. We thank Alex Slivkins for pointing us to the problem and initial fruitful discussions.

References
Alekh Agarwal, Daniel Hsu, Satyen Kale, John Langford, Lihong Li, and Robert Schapire. 2014.
Taming the monster: A fast and simple algorithm for contextual bandits. In International Conference
on Machine Learning. PMLR, 1638â€“1646.
Alekh Agarwal, Haipeng Luo, Behnam Neyshabur, and Robert E Schapire. 2017. Corralling a band
of bandit algorithms. In Conference on Learning Theory. PMLR, 12â€“38.
Shipra Agrawal, Nikhil R Devanur, and Lihong Li. 2016. An efficient algorithm for contextual
bandits with knapsacks, and an extension to concave objectives. In Conference on Learning Theory.
PMLR, 4â€“18.
Peter Auer, Nicolo Cesa-Bianchi, and Paul Fischer. 2002. Finite-time analysis of the multiarmed
bandit problem. Machine learning 47 (2002), 235â€“256.
Peter Auer, Nicolo Cesa-Bianchi, Yoav Freund, and Robert E Schapire. 1995. Gambling in a
rigged casino: The adversarial multi-armed bandit problem. In Proceedings of IEEE 36th annual
foundations of computer science. IEEE, 322â€“331.
Alina Beygelzimer, John Langford, Lihong Li, Lev Reyzin, and Robert Schapire. 2011. Contextual
bandit algorithms with supervised learning guarantees. In Proceedings of the Fourteenth International Conference on Artificial Intelligence and Statistics. JMLR Workshop and Conference
Proceedings, 19â€“26.
Adam Block, Yuval Dagan, Noah Golowich, and Alexander Rakhlin. 2022. Smoothed online learning
is as easy as statistical learning. arXiv preprint arXiv:2202.04690 (2022).
Nicolo Cesa-Bianchi, Yoav Freund, David Haussler, David P Helmbold, Robert E Schapire, and
Manfred K Warmuth. 1997. How to use expert advice. Journal of the ACM (JACM) 44, 3 (1997),
427â€“485.
10

Yifang Chen, Chung-Wei Lee, Haipeng Luo, and Chen-Yu Wei. 2019. A new algorithm for nonstationary contextual bandits: Efficient, optimal and parameter-free. In Conference on Learning
Theory. PMLR, 696â€“726.
Wei Chu, Lihong Li, Lev Reyzin, and Robert Schapire. 2011. Contextual bandits with linear payoff
functions. In Proceedings of the Fourteenth International Conference on Artificial Intelligence and
Statistics. JMLR Workshop and Conference Proceedings, 208â€“214.
Ashok Cutkosky and Kwabena Boahen. 2017. Online learning without prior information. In Conference on Learning Theory. PMLR, 643â€“677.
Miroslav DudÃ­k, Nika Haghtalab, Haipeng Luo, Robert E Schapire, Vasilis Syrgkanis, and Jennifer Wortman Vaughan. 2020. Oracle-efficient online learning and auction design. Journal of the
ACM (JACM) 67, 5 (2020), 1â€“57.
Miroslav Dudik, Daniel Hsu, Satyen Kale, Nikos Karampatziakis, John Langford, Lev Reyzin,
and Tong Zhang. 2011. Efficient optimal learning for contextual bandits. arXiv preprint
arXiv:1106.2369 (2011).
Dylan J Foster, Sham M Kakade, Jian Qian, and Alexander Rakhlin. 2021. The statistical complexity
of interactive decision making. arXiv preprint arXiv:2112.13487 (2021).
Nika Haghtalab, Yanjun Han, Abhishek Shetty, and Kunhe Yang. 2022. Oracle-Efficient Online
Learning for Beyond Worst-Case Adversaries. arXiv preprint arXiv:2202.08549 (2022).
Elad Hazan and Tomer Koren. 2016. The computational power of optimization in online learning. In
Proceedings of the forty-eighth annual ACM symposium on Theory of Computing. 128â€“141.
Adam Kalai and Santosh Vempala. 2005. Efficient algorithms for online decision problems. J.
Comput. System Sci. 71, 3 (2005), 291â€“307.
Akshay Krishnamurthy, Alekh Agarwal, and Miro Dudik. 2016. Contextual semibandits via supervised learning oracles. Advances In Neural Information Processing Systems 29 (2016).
John Langford and Tong Zhang. 2007. The epoch-greedy algorithm for contextual multi-armed
bandits. Advances in neural information processing systems 20, 1 (2007), 96â€“1.
Tyler Lu, DÃ¡vid PÃ¡l, and Martin PÃ¡l. 2009. Showing relevant ads via context multi-armed bandits. In
Proceedings of AISTATS.
Haipeng Luo, Chen-Yu Wei, Alekh Agarwal, and John Langford. 2018. Efficient contextual bandits
in non-stationary worlds. In Conference On Learning Theory. PMLR, 1739â€“1776.
Alexander Rakhlin and Karthik Sridharan. 2015. Hierarchies of relaxations for online prediction
problems with evolving constraints. In Conference on Learning Theory. PMLR, 1457â€“1479.
Alexander Rakhlin and Karthik Sridharan. 2016. Bistro: An efficient relaxation-based method for
contextual bandits. In International Conference on Machine Learning. PMLR, 1977â€“1985.
Sasha Rakhlin, Ohad Shamir, and Karthik Sridharan. 2012. Relax and randomize: From value to
algorithms. Advances in Neural Information Processing Systems 25 (2012).
David Simchi-Levi and Yunzong Xu. 2022. Bypassing the monster: A faster and simpler optimal
algorithm for contextual bandits under realizability. Mathematics of Operations Research 47, 3
(2022), 1904â€“1931.
Aleksandrs Slivkins. 2009. Contextual Bandits with Similarity Information. CoRR abs/0907.3986
(2009). arXiv:0907.3986 http://arxiv.org/abs/0907.3986
Aleksandrs Slivkins. 2019. Introduction to multi-armed bandits. Foundations and TrendsÂ® in
Machine Learning 12, 1-2 (2019), 1â€“286.
Arun Suggala and Praneeth Netrapalli. 2020. Follow the perturbed leader: Optimism and fast parallel
algorithms for smooth minimax games. Advances in Neural Information Processing Systems 33
(2020), 22316â€“22326.
11

Vasilis Syrgkanis, Akshay Krishnamurthy, and Robert Schapire. 2016a. Efficient algorithms for
adversarial contextual learning. In International Conference on Machine Learning. PMLR, 2159â€“
2168.
Vasilis Syrgkanis, Haipeng Luo, Akshay Krishnamurthy, and Robert E Schapire. 2016b. Improved
regret bounds for oracle-based adversarial contextual bandits. Advances in Neural Information
Processing Systems 29 (2016).

12

A

Proof of Theorem 7

Combining Equation 8 and Theorem 6 we obtain
s
T K log(|Î |)
+ Î³T.
R EGT â‰¤ 4
Î³
Setting the derivative with respect to Î³ of RHS to zero, we obtain
p
T âˆ’ 2 T K log |Î |Î³ âˆ’3/2 = 0,

1/3
4K log |Î |
which is equivalent to Î³ =
. Note however that Î³ needs to satisfy Î³ >
T
KT âˆ’1 log(|Î |)/2 and Î³ â‰¤ 1. To verify the first condition, we should have T > K log(|Î |)/(2Î³).
Putting our designated Î³ implies that T should satisfy
T > K log(|Î |) Â· (

T
T
)1/3 Â· 1/2 â‡â‡’ T 3 > K 3 log3 (|Î |)
Â· 1/8
4K log(|Î |)
4K log(|Î |)
â‡â‡’ T 2 >

K 2 log2 |Î |
K log |Î |
âˆš
,
â‡â‡’ T >
32
4 2

which holds by assumption. To verify the second condition of Î³ â‰¤ 1, we need to have T >
4K log(|Î |), which again holds by assumption.
Plugging Î³ to the regret bound, we have
O(T 2/3 (K log |Î |)1/3 ),
completing the proof.

B

Proof of Lemma 4

The proof is based on Lemma 4 in Syrgkanis et al. (2016b) and is provided for completeness. The
pseudocode of our algorithm is provided in Algorithm 2.
Algorithm 2: Compute qtâˆ—
Input: value-of-ERM oracle, (x, cÌ‚)1:tâˆ’1 , xt and Ït
Output: qtâˆ— (Ït ) as in Equation 6
Compute for all i âˆˆ [K], Ïˆi = inf Ï€âˆˆÎ  of
tâˆ’1
X

cÌ‚Ï„ (Ï€(xÏ„ )) +

Ï„ =1

T
X
K
ei (Ï€(xt )) +
2ZÏ„ ÎµÏ„ (Ï€(xÏ„ ))
Î³
Ï„ =t+1

using the value-of-ERM oracle
Compute Î·i = Î³(ÏˆiKâˆ’Ïˆ0 ) for all i âˆˆ [K]
Set m = 1, q = 0
for k = 1, 2, . . . , K do
q(i) â† min{(Î·i )+ , m}, m â† m âˆ’ q(i)
end
If m > 0, distribute remaining m uniformly across coordinates of q

Proof. We prove the result by rewriting the minimizer equation to be composed of only calls to our
value-of-ERM oracle. For i âˆˆ [K], we define Ïˆi to be
!
tâˆ’1
T
X
X
âˆ’1
inf
cÌ‚Ï„ (Ï€(xÏ„ )) + Î³ Kei (Ï€(xt )) +
2ZÏ„ ÎµÏ„ (Ï€(xÏ„ ))
Ï€âˆˆÎ 

Ï„ =1

Ï„ =t+1

where e0 = 0. We can thus write the definition of qtâˆ— (Ït ) as
arg inf

sup

K
X

qâˆˆâˆ†K pt âˆˆâˆ†0


pt (i)

D i=1

Kq(i)
âˆ’ Ïˆi
Î³


âˆ’ p(0) Â· Ïˆ0

and note that the values of Ïˆi can be computed via a single call to the value-of-ERM oracle, and
moreover we require K + 1 calls to compute all the Ïˆi .
Now to compute the minimizer of the above, we first let zi = Kq(i)
âˆ’ Ïˆi and z0 = âˆ’Ïˆ0 and rewrite
Î³
the minimax value as
arg inf sup

K
X

qâˆˆâˆ†D pt âˆˆâˆ†0D i=1

pt (i) Â· zi + pt (0) Â· z0 .

We reiterate that each pt (i) â‰¤ Î³/K for i > 0 and thus we must distribute maximal probability
across the zi coordinates of largest value, i.e. we will put as much probability weight as permitted
on arg maxiâˆˆ[K] zi , and proceed to do the same for the second largest value, repeating the process
until we exhaust the probability distribution or reach the terminal z0 . At this point, we can put the
remainder of the probability weight on this final coordinate to ensure summation to 1.
To proceed in analyzing the above water-filling argument, sort the coordinates zi such that z(1) â‰¥
z(2) â‰¥ ... â‰¥ z(K) for i > 0 and further define index Âµ to be the smallest index such that z(Âµ) â‰¥ z0 .
By the probability weight distribution argument above, we can reduce the supremum over pt to be
Âµ
X
Î³
i=1

z(i) + (1 âˆ’

K

Âµ
X
Î³
Î³
Âµ)z0 =
(z(i) âˆ’ z0 ) + z0 .
K
K
i=1

since we maximize p(i) for the z(i) in order and set p(i) = 0 for terms less than z0 , which would
otherwise yield an addition of negative terms in the above summation. Thus, by definition of Âµ, we
have for i > Âµ
Âµ
X
Î³

K
i=1

(z(i) âˆ’ z0 ) + z0 =

K
X
Î³

K
i=1

(z(i) âˆ’ z0 )+ + z0 .

where the + superscript denotes the R E LU operator, (x)+ = max{x, 0}. Therefore, the minimax
expression is reformulated as
arg inf

K
X
Î³

qâˆˆâˆ†D

K
i=1

(z(i) âˆ’ z0 )+ + z0 .

which is equivalent to minimizing the R E LU term
arg inf

qâˆˆâˆ†D

K
X
Î³
i=1

K

(z(i) âˆ’ z0 )+ = arg inf

qâˆˆâˆ†D

K 
X

q(i) âˆ’

i=1

+
Î³
Â· (Ïˆi âˆ’ Ïˆ0 ) .
K

Simplify notation by setting Î·i = Î³(ÏˆiKâˆ’Ïˆ0 ) so that the expression becomes
arg inf

qâˆˆâˆ†D

K
X

(q(i) âˆ’ Î·i )+ .

i=1

We argue the minimization procedure as follows: select i âˆˆ [K] such that Î·i â‰¤ 0. Any positive
probability weight on q(i) will yield an increase in the expression, whereas for Î·i > 0 we experience
no increase in the P
objective until the value of Î·i surpasses q(i). Thus, the minimizer will weight the
actions with min{ i:Î·i >0 Î·i , 1} on the coordinates with Î·i > 0 and distribute the remaining weight
(if nonzero) arbitrarily among [K]. This is more precisely outlined in the pseudocode of Algorithm
2.
14

C

Proof of Lemma 8

Proof of Lemma 8. Denote by qtâˆ— = EÏt [qtâˆ— (Ït )]. We note that since we are drawing from Ït , calculating qtâˆ— (Ït ), and then drawing from qtâˆ— (Ït ), our algorithm is effectively sampling from qtâˆ— , even
though we do not calculate qtâˆ— explicitly. Now note that


1
âˆ—
EyÌ‚t âˆ¼qt [ct (yÌ‚t )] = hqt , ct i â‰¤ hqt , ct i + Î³
, ct â‰¤ EyÌ‚t ,cÌ‚t [hqtâˆ— , cÌ‚t i] + Î³.
K
holds by definition of qt (Ït ) and the assumed bounds on ct . Thus, it further holds that
EyÌ‚t ,cÌ‚t [ct (yÌ‚t ) + R EL(I1:t )] â‰¤ Î³ +

sup
ct âˆˆ[0,1]K

sup
ct âˆˆ[0,1]K

EyÌ‚t ,cÌ‚t [hqtâˆ— , cÌ‚t i + R EL(I1:t )] .

By expansion of the second term on the right hand side, we rewrite the relation as
sup
ct âˆˆ[0,1]K

=

EyÌ‚t ,cÌ‚t [hqtâˆ— , cÌ‚t i + R EL(I1:t )]

sup
ct âˆˆ[0,1]K

=

sup
ct âˆˆ[0,1]K

=

sup
ct âˆˆ[0,1]K

EyÌ‚t ,cÌ‚t [hqtâˆ— , cÌ‚t i + EÏt [R((x, cÌ‚)1:t , Ït )]]



âˆ—
EyÌ‚t ,cÌ‚t hqt , cÌ‚t i + EÏt sup (âˆ’cÌ‚t (Ï€(xt )) + AÏ€,t ) + Î³(T âˆ’ t)
Ï€âˆˆÎ 




EyÌ‚t ,cÌ‚t EÏt hqtâˆ— (Ït ), cÌ‚t i + sup (âˆ’cÌ‚t (Ï€(xt )) + AÏ€,t ) + Î³(T âˆ’ t).
Ï€âˆˆÎ 

Furthermore, the symmetric construction of cÌ‚t implies that cÌ‚t takes the value Kei /Î³ with probability
at most Î³/K. Therefore, we know that cÌ‚t is sampled from a pt âˆˆ âˆ†0D where âˆ†0D is defined as in
Equation (5). Taking the maximum over all possible pt , we bound the supremum term above with



sup EyÌ‚t ,cÌ‚t EÏt hqtâˆ— (Ït ), cÌ‚t i + sup (âˆ’cÌ‚t (Ï€(xt )) + AÏ€,t )
Ï€âˆˆÎ 

ct âˆˆ[0,1]K




âˆ—
â‰¤ sup EcÌ‚t âˆ¼pt EÏt hqt (Ït ), cÌ‚t i + sup (âˆ’cÌ‚t (Ï€(xt )) + AÏ€,t )
pt âˆˆâˆ†0D

"
â‰¤ EÏt

Ï€âˆˆÎ 


#
âˆ—
sup EcÌ‚t âˆ¼pt hqt (Ït ), cÌ‚t i + sup (âˆ’cÌ‚t (Ï€(xt )) + AÏ€,t ) .

pt âˆˆâˆ†0D

Ï€âˆˆÎ 

where the second inequality is an application of Jensenâ€™s inequality. We first replace the optimized qtâˆ—
by the corresponding infimum operator over qt , thus the term inside the expectation is equivalent to


inf sup EcÌ‚t âˆ¼pt hq, cÌ‚t i + sup (âˆ’cÌ‚t (Ï€(xt )) + AÏ€,t ) .
qâˆˆâˆ†K pt âˆˆâˆ†0

Ï€âˆˆÎ 

D

conditioned on Ït . By the minimax theorem, we can interchange the infimum and supremum operators
without decreasing the quantity, and this is further upper bounded as


inf sup EcÌ‚t âˆ¼pt hq, cÌ‚t i + sup (âˆ’cÌ‚t (Ï€(xt )) + AÏ€,t )
qâˆˆâˆ†K pt âˆˆâˆ†0

D

= sup

Ï€âˆˆÎ 



inf EcÌ‚t âˆ¼pt hq, cÌ‚t i + sup (âˆ’cÌ‚t (Ï€(xt )) + AÏ€,t ) .

pt âˆˆâˆ†0D qâˆˆâˆ†K

Ï€âˆˆÎ 

and moreover, since the objective is linear with respect to qt we can instead work with


sup min EcÌ‚t âˆ¼pt cÌ‚t (i) + sup (âˆ’cÌ‚t (Ï€(xt )) + AÏ€,t ) .
pt âˆˆâˆ†0D iâˆˆ[K]

Ï€âˆˆÎ 

15

Symmmetrization permits us to rewrite the above as


sup min EcÌ‚t âˆ¼pt cÌ‚t (i) + sup (âˆ’cÌ‚t (Ï€(xt )) + AÏ€,t )
pt âˆˆâˆ†0D iâˆˆ[K]

Ï€âˆˆÎ 





= sup EcÌ‚t âˆ¼pt sup
pt âˆˆâˆ†0D

Ï€âˆˆÎ 

min EcÌ‚0t âˆ¼pt [cÌ‚0t (i)] âˆ’ cÌ‚t (Ï€(xt )) + AÏ€,t
iâˆˆ[K]



â‰¤ sup EcÌ‚t âˆ¼pt sup EcÌ‚0t âˆ¼pt [cÌ‚0t (Ï€(xt ))] âˆ’ cÌ‚t (Ï€(xt )) + AÏ€,t
pt âˆˆâˆ†0D






Ï€âˆˆÎ 



â‰¤ sup EcÌ‚t ,cÌ‚0t âˆ¼pt sup (cÌ‚0t (Ï€(xt )) âˆ’ cÌ‚t (Ï€(xt )) + AÏ€,t ) .
pt âˆˆâˆ†0D

Ï€âˆˆÎ 

where the last inequality is an additional application of Jensenâ€™s inequality. Since cÌ‚t , cÌ‚0t are sampled
from the same distribution, this can be rewritten as


0
0
sup EcÌ‚t ,cÌ‚t âˆ¼pt sup (cÌ‚t (Ï€(xt )) âˆ’ cÌ‚t (Ï€(xt )) + AÏ€,t )
pt âˆˆâˆ†0D

Ï€âˆˆÎ 



= sup EcÌ‚t ,cÌ‚0t âˆ¼pt ,Î´ sup (Î´(cÌ‚0t (Ï€(xt )) âˆ’ cÌ‚t (Ï€(xt ))) + AÏ€,t )
pt âˆˆâˆ†0D

Ï€âˆˆÎ 


= sup EcÌ‚t ,cÌ‚0t âˆ¼pt ,Î´
pt âˆˆâˆ†0D



sup (Î´cÌ‚0t (Ï€(xt )) âˆ’ Î´cÌ‚t (Ï€(xt )) + AÏ€,t )
Ï€âˆˆÎ 

.

and further split the term within the inner supremum to obtain


0
sup EcÌ‚t ,cÌ‚0t âˆ¼pt ,Î´ sup (Î´cÌ‚t (Ï€(xt )) âˆ’ Î´cÌ‚t (Ï€(xt )) + AÏ€,t )
pt âˆˆâˆ†0D

Ï€âˆˆÎ 




AÏ€,t
AÏ€,t
âˆ’ Î´cÌ‚t (Ï€(xt )) +
= sup EcÌ‚t ,cÌ‚0t âˆ¼pt ,Î´ sup Î´cÌ‚0t (Ï€(xt )) +
2
2
Ï€âˆˆÎ 
pt âˆˆâˆ†0D





AÏ€,t
AÏ€,t
â‰¤ sup EcÌ‚t ,cÌ‚0t âˆ¼pt ,Î´ sup Î´cÌ‚0t (Ï€(xt )) +
+ sup âˆ’Î´cÌ‚t (Ï€(xt )) +
2
2
Ï€âˆˆÎ 
Ï€âˆˆÎ 
pt âˆˆâˆ†0D


= sup EcÌ‚t âˆ¼pt ,Î´ sup (2Î´cÌ‚t (Ï€(xt )) + AÏ€,t ) .
pt âˆˆâˆ†0D

D

Ï€âˆˆÎ 

Proof of the final step condition

Lemma 10. The relaxation function (4) satisfies the final step condition (2).
Proof. By setting t = T in our relaxation R EL(I1:T ) and definition of our unbiased estimator cÌ‚t of
ct ,
"
#
T
X
EyÌ‚1:T [R EL(I1:T )] = EyÌ‚1:T âˆ’ sup
cÌ‚Ï„ (Ï€(xÏ„ ))
Ï€âˆˆÎ  Ï„ =1

â‰¥ sup âˆ’EyÌ‚1:T
Ï€âˆˆÎ 

= sup âˆ’
Ï€âˆˆÎ 

16

" T
X

#
cÌ‚Ï„ (Ï€(xÏ„ ))

Ï„ =1
T
X
Ï„ =1

cÏ„ (Ï€(xÏ„ )).

